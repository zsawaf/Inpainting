// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "VisCompUI.h"
#include "fltk_includes.h"

void VisCompUI::cb_Open_i(Fl_Menu_*, void*) {
  left_panel->set(interactive_load_image("Left Image"), "Left Image");
}
void VisCompUI::cb_Open(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Open_i(o,v);
}

void VisCompUI::cb_Open1_i(Fl_Menu_*, void*) {
  right_panel->set(interactive_load_image("Right Image"), "Right Image");
}
void VisCompUI::cb_Open1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Open1_i(o,v);
}

void VisCompUI::cb_Open2_i(Fl_Menu_*, void*) {
  #include "file_callbacks/callback_open_drawing.h"
}
void VisCompUI::cb_Open2(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Open2_i(o,v);
}

void VisCompUI::cb_Save_i(Fl_Menu_*, void*) {
  #include "file_callbacks/callback_save_image.h"
}
void VisCompUI::cb_Save(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void VisCompUI::cb_Save1_i(Fl_Menu_*, void*) {
  #include "file_callbacks/callback_save_drawing.h"
}
void VisCompUI::cb_Save1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Save1_i(o,v);
}

void VisCompUI::cb_Quit_i(Fl_Menu_*, void*) {
  exit(1);
}
void VisCompUI::cb_Quit(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Quit_i(o,v);
}

void VisCompUI::cb_Display_i(Fl_Menu_*, void*) {
  if (mattingDisplayWindow->visible() == false) {
   mattingDisplayWindow->show();
} else
   mattingDisplayWindow->hide();
}
void VisCompUI::cb_Display(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Display_i(o,v);
}

void VisCompUI::cb_back1_i(Fl_Menu_*, void*) {
  // load an image interactively and store it as the Background 1 image
// and, if successful, show it in the left panel
load_and_display_matting_image(left_panel, M.Back1);
}
void VisCompUI::cb_back1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_back1_i(o,v);
}

void VisCompUI::cb_back2_i(Fl_Menu_*, void*) {
  // load an image interactively and store it as the Background 2 image
// and, if successful, show it in the right panel
load_and_display_matting_image(right_panel, M.Back2);
}
void VisCompUI::cb_back2(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_back2_i(o,v);
}

void VisCompUI::cb_comp1_i(Fl_Menu_*, void*) {
  // load an image interactively and store it as the Composite 1 image
// and, if successful, show it in the left panel
load_and_display_matting_image(left_panel, M.Comp1);
}
void VisCompUI::cb_comp1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_comp1_i(o,v);
}

void VisCompUI::cb_comp2_i(Fl_Menu_*, void*) {
  // load an image interactively and store it as the Composite 2 image
// and, if successful, show it in the right panel
load_and_display_matting_image(right_panel, M.Comp2);
}
void VisCompUI::cb_comp2(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_comp2_i(o,v);
}

void VisCompUI::cb_Run_i(Fl_Menu_*, void*) {
  {
        // if we have already ran the algorithm on the current set of
        // input images, we don't need to run it again
	if (M.compute() == true) {
		fl_alert("Separation successful.\
			\nUse \"Matting/Show Alpha\" to view the alpha matte\nand \"Matting/Show Foreground\" to view the foreground object");


		// show the alpha matte in the left canvas

		// first we retrieve the computed alpha matte
        // then we display it and show the title string
        // we use to describe alpha mattes 
		left_panel->set(M.get1(M.Alpha), M.get_title(M.Alpha));

		// show the object in the right canvas
		right_panel->set(M.get(M.Object), M.get_title(M.Object));
	} else
		fl_alert("Triangulation matting cannot be applied yet.");
};
}
void VisCompUI::cb_Run(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Run_i(o,v);
}

void VisCompUI::cb_Create_i(Fl_Menu_*, void*) {
  {
  vil_image_view<vil_rgb<vxl_byte> > im1;
  vil_image_view<vil_rgb<vxl_byte> > im2;

  // load an image interactively and set its title to be
  // the string we use to describe new background images 
  im1 = interactive_load_image(M.get_title(M.NewBack));
  // if the image returned is empty
  if ((bool) im1 == false)
	  fl_alert("vil_load(): Error opening image file.");
  else // ok, we can do the compositing operation
	  if (M.compute_composite(im1, im2) == true) {
         // show the background image in the left panel
		 left_panel->set(im1, M.get_title(M.NewBack));
         // show the new composite in the right panel
		 right_panel->set(im2, M.get_title(M.NewComp));
	  } else
		  fl_alert("compute_composite(): Composite cannot be computed");
};
}
void VisCompUI::cb_Create(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Create_i(o,v);
}

void VisCompUI::cb_Display1_i(Fl_Menu_*, void*) {
  if (inpaintingDisplayWindow->visible() == false) {
   inpaintingDisplayWindow->show();
} else
   inpaintingDisplayWindow->hide();
}
void VisCompUI::cb_Display1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Display1_i(o,v);
}

void VisCompUI::cb_source_i(Fl_Menu_*, void*) {
  // load an image interactively and store it as the Background 1 image
// and, if successful, show it in the left panel
load_and_display_inpainting_image(left_panel, I->Source);
}
void VisCompUI::cb_source(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_source_i(o,v);
}

void VisCompUI::cb_mask_i(Fl_Menu_*, void*) {
  // load an image interactively and store it as the Background 2 image
// and, if successful, show it in the right panel
load_and_display_inpainting_image1(right_panel, I->Init_Filled);
}
void VisCompUI::cb_mask(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_mask_i(o,v);
}

void VisCompUI::cb_inpainted_i(Fl_Menu_*, void*) {
  {
   vil_image_view<vxl_byte> im;
   im = I->get(I->Inpainted);
   if ((bool) im == true) {
      char* fname;
      fname = fl_file_chooser(I->get_title(I->Inpainted).c_str(), "", "");
      if (fname != NULL)
            vil_save((vil_image_view<vxl_byte>)im, fname);
   } else
      fl_alert("inpainting::get(): inpainted image not available.");
};
}
void VisCompUI::cb_inpainted(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_inpainted_i(o,v);
}

void VisCompUI::cb_mask1_i(Fl_Menu_*, void*) {
  {
  vil_image_view<bool> mask;
  ImDraw* panel = 0;
  mask.clear();

  // if the left panel is in drawing mode
  if (left_panel->drawing_mode())
     panel = left_panel;
  else if (right_panel->drawing_mode())
     panel = right_panel;
  
  if (panel->canonical_view() == false)
     fl_alert("Press the Canonical View button before saving mask");
  else 
    if (panel != 0) {
	mask = panel->get_alpha_image();
	if ((bool) mask == true) {
     		// get the already-drawn mask and save it to a file
	        char* fname;
	   
	        fname = fl_file_chooser("Save Drawn Mask to File", "", "");
                if (fname != NULL) {
                   if (I->set(I->Init_Filled,mask ) == true)
		        vil_save(I->get1(I->Init_Filled), fname);
        	} else
	     		fl_alert("VisCompUI:vil_save(): Image save failed.");
  	  } else
        	fl_alert("VisCompUI: Drawing not available");
   } else
       fl_alert("VisCompUI: at least one panel must be in drawing mode!");
};
}
void VisCompUI::cb_mask1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_mask1_i(o,v);
}

void VisCompUI::cb_Inpainted_i(Fl_Menu_*, void*) {
  {
   vil_image_view<vil_rgb<vxl_byte> > im;

   im = I->get(I->Inpainted);
   if ((bool) im == true)
        if (I->set(I->Source, im) == true)
		display_inpainting_image(left_panel,I->Source);
        else
		fl_alert("inpainting::set() cannot convert to source image for inpainting");
   else 
       fl_alert("inpainting::get(): Inpainted image not available");
};
}
void VisCompUI::cb_Inpainted(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Inpainted_i(o,v);
}

void VisCompUI::cb_Drawing_i(Fl_Menu_*, void*) {
  {
  vil_image_view<bool> mask;
  ImDraw* panel = 0;

  // if the left panel is in drawing mode
  if (left_panel->drawing_mode())
     panel = left_panel;
  else if (right_panel->drawing_mode())
     panel = right_panel;
  
  if (panel->canonical_view() == false)
     fl_alert("Press the Canonical View button before transfer");
  else 
    if (panel != 0) {
	mask = panel->get_alpha_image();
	if ((bool) mask == true) {
     		// get the already-drawn mask and set it to be the
        	// mask used by the inpainting algorithm
 		if (I->set(I->Init_Filled,mask ) == true) {
   			// if the image was loaded in the data structure correctly, show it in the
	     		// specified panel
			panel->clear_objects();    
             		display_inpainting_image1(panel,I->Init_Filled);
        	} else
	     		fl_alert("VisCompUI: Image transfer failed.");
  	  } else
        	fl_alert("VisCompUI: Drawing not available");
   } else
       fl_alert("VisCompUI: at least one panel must be in drawing mode!");
};
}
void VisCompUI::cb_Drawing(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Drawing_i(o,v);
}

void VisCompUI::cb_Run1_i(Fl_Menu_*, void*) {
  {
        // if we have already ran the algorithm on the current set of
        // input images, we don't need to run it again
	if (I->compute() == false)
		fl_alert("Inpainting cannot be performed yet.");
        mainWindow->redraw();
};
}
void VisCompUI::cb_Run1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Run1_i(o,v);
}

void VisCompUI::cb_Step_i(Fl_Menu_*, void*) {
  {
        // if we have already ran the algorithm on the current set of
        // input images, we don't need to run it again
	if (I->compute(inpainting_iterations_per_step) == false)
		fl_alert("Inpainting cannot be performed yet.");
    mainWindow->redraw();
};
}
void VisCompUI::cb_Step(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Step_i(o,v);
}

void VisCompUI::cb_Mask_i(Fl_Menu_*, void*) {
  // undo the last drawing operation
if (left_panel->drawing_mode()) 
	left_panel->undo();
else if (right_panel->drawing_mode())
	right_panel->undo();
}
void VisCompUI::cb_Mask(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Mask_i(o,v);
}

void VisCompUI::cb_Mask1_i(Fl_Menu_*, void*) {
  // undo the last drawing operation
if (left_panel->drawing_mode())
	left_panel->clear_objects();
else if (right_panel->drawing_mode())
	right_panel->clear_objects();
}
void VisCompUI::cb_Mask1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Mask1_i(o,v);
}

Fl_Menu_Item VisCompUI::menu_Main[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Left Image", 0,  (Fl_Callback*)VisCompUI::cb_Open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Right Image", 0,  (Fl_Callback*)VisCompUI::cb_Open1, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Drawing", 0,  (Fl_Callback*)VisCompUI::cb_Open2, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Thresholded Image", 0,  (Fl_Callback*)VisCompUI::cb_Save, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Drawing", 0,  (Fl_Callback*)VisCompUI::cb_Save1, 0, 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Quit", 0x80071,  (Fl_Callback*)VisCompUI::cb_Quit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Triangulation Matting", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Display Control", 0,  (Fl_Callback*)VisCompUI::cb_Display, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"Load", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"back1", 0,  (Fl_Callback*)VisCompUI::cb_back1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"back2", 0,  (Fl_Callback*)VisCompUI::cb_back2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"comp1", 0,  (Fl_Callback*)VisCompUI::cb_comp1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"comp2", 0,  (Fl_Callback*)VisCompUI::cb_comp2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Run Algorithm", 0,  (Fl_Callback*)VisCompUI::cb_Run, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Create Composite", 0,  (Fl_Callback*)VisCompUI::cb_Create, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Inpainting", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Display Control", 0x40064,  (Fl_Callback*)VisCompUI::cb_Display1, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"Load", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"source", 0x80073,  (Fl_Callback*)VisCompUI::cb_source, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"mask", 0x80064,  (Fl_Callback*)VisCompUI::cb_mask, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Save", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"inpainted", 0x80069,  (Fl_Callback*)VisCompUI::cb_inpainted, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"mask", 0x8006d,  (Fl_Callback*)VisCompUI::cb_mask1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Transfer", 0,  0, 0, 192, FL_NORMAL_LABEL, 0, 14, 0},
 {"Inpainted -> Source", 0x40069,  (Fl_Callback*)VisCompUI::cb_Inpainted, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Drawing -> Initial Mask", 0x4006d,  (Fl_Callback*)VisCompUI::cb_Drawing, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Run Algorithm", 0x80072,  (Fl_Callback*)VisCompUI::cb_Run1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Step Algorithm", 0x8006e,  (Fl_Callback*)VisCompUI::cb_Step, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {"Mask Undo", 0x4007a,  (Fl_Callback*)VisCompUI::cb_Mask, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Mask Clear ", 0x40063,  (Fl_Callback*)VisCompUI::cb_Mask1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

void VisCompUI::cb_Browse_i(Fl_Menu_*, void*) {
  left_panel->set_browsing_mode();
right_panel->set_browsing_mode();
}
void VisCompUI::cb_Browse(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Browse_i(o,v);
}

void VisCompUI::cb_Draw_i(Fl_Menu_*, void*) {
  left_panel->set_drawing_mode();
right_panel->set_browsing_mode();
}
void VisCompUI::cb_Draw(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Draw_i(o,v);
}

void VisCompUI::cb_Draw1_i(Fl_Menu_*, void*) {
  right_panel->set_drawing_mode();
left_panel->set_browsing_mode();
}
void VisCompUI::cb_Draw1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Draw1_i(o,v);
}

Fl_Menu_Item VisCompUI::menu_Mode[] = {
 {"Browse", 0,  (Fl_Callback*)VisCompUI::cb_Browse, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Draw Left", 0,  (Fl_Callback*)VisCompUI::cb_Draw, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Draw Right", 0,  (Fl_Callback*)VisCompUI::cb_Draw1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void VisCompUI::cb_left_mag_i(Fl_Input*, void*) {
  {
  double new_mag;

  sscanf(left_mag->value(),"%lg", &new_mag);
  left_panel->mag(new_mag);
};
}
void VisCompUI::cb_left_mag(Fl_Input* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_left_mag_i(o,v);
}

void VisCompUI::cb_left_center_i_i(Fl_Input* o, void*) {
  {
  int i;

  sscanf(((Fl_Input *)o)->value(),"%d", &i);
  left_panel->recenter_i(i);
};
}
void VisCompUI::cb_left_center_i(Fl_Input* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_left_center_i_i(o,v);
}

void VisCompUI::cb_left_center_j_i(Fl_Input* o, void*) {
  {
  int j;

  sscanf(((Fl_Input *)o)->value(),"%d", &j);
  left_panel->recenter_j(j);
};
}
void VisCompUI::cb_left_center_j(Fl_Input* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_left_center_j_i(o,v);
}

void VisCompUI::cb_Canonical_i(Fl_Button*, void*) {
  left_panel->set_canonical_view();
}
void VisCompUI::cb_Canonical(Fl_Button* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_Canonical_i(o,v);
}

void VisCompUI::cb_right_mag_i(Fl_Input*, void*) {
  {
  double new_mag;

  sscanf(right_mag->value(),"%lg", &new_mag);
  right_panel->mag(new_mag);
};
}
void VisCompUI::cb_right_mag(Fl_Input* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_right_mag_i(o,v);
}

void VisCompUI::cb_right_center_i_i(Fl_Input* o, void*) {
  {
  int i;

  sscanf(((Fl_Input *)o)->value(),"%d", &i);
  right_panel->recenter_i(i);
};
}
void VisCompUI::cb_right_center_i(Fl_Input* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_right_center_i_i(o,v);
}

void VisCompUI::cb_right_center_j_i(Fl_Input* o, void*) {
  {
  int j;

  sscanf(((Fl_Input *)o)->value(),"%d", &j);
  right_panel->recenter_j(j);
};
}
void VisCompUI::cb_right_center_j(Fl_Input* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_right_center_j_i(o,v);
}

void VisCompUI::cb_Canonical1_i(Fl_Button*, void*) {
  right_panel->set_canonical_view();
}
void VisCompUI::cb_Canonical1(Fl_Button* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_Canonical1_i(o,v);
}

void VisCompUI::cb_back11_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_matting_image(left_panel, M.Back1);
}
void VisCompUI::cb_back11(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_back11_i(o,v);
}

void VisCompUI::cb_back21_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_matting_image(left_panel, M.Back2);
}
void VisCompUI::cb_back21(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_back21_i(o,v);
}

void VisCompUI::cb_comp11_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_matting_image(left_panel, M.Comp1);
}
void VisCompUI::cb_comp11(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_comp11_i(o,v);
}

void VisCompUI::cb_comp21_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_matting_image(left_panel, M.Comp2);
}
void VisCompUI::cb_comp21(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_comp21_i(o,v);
}

void VisCompUI::cb_alpha_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images (eg. alpha mattes)
display_matting_image1(left_panel, M.Alpha);
}
void VisCompUI::cb_alpha(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_alpha_i(o,v);
}

void VisCompUI::cb_object_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_matting_image(left_panel, M.Object);
}
void VisCompUI::cb_object(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_object_i(o,v);
}

void VisCompUI::cb_nback_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_matting_image(left_panel, M.NewBack);
}
void VisCompUI::cb_nback(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_nback_i(o,v);
}

void VisCompUI::cb_ncomp_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_matting_image(left_panel, M.NewComp);
}
void VisCompUI::cb_ncomp(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_ncomp_i(o,v);
}

Fl_Menu_Item VisCompUI::menu_Left[] = {
 {"  ", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"back1", 0,  (Fl_Callback*)VisCompUI::cb_back11, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"back2", 0,  (Fl_Callback*)VisCompUI::cb_back21, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"comp1", 0,  (Fl_Callback*)VisCompUI::cb_comp11, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"comp2", 0,  (Fl_Callback*)VisCompUI::cb_comp21, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"alpha", 0,  (Fl_Callback*)VisCompUI::cb_alpha, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"object", 0,  (Fl_Callback*)VisCompUI::cb_object, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"nback", 0,  (Fl_Callback*)VisCompUI::cb_nback, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"ncomp", 0,  (Fl_Callback*)VisCompUI::cb_ncomp, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item VisCompUI::menu_Right[] = {
 {"  ", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void VisCompUI::cb_source1_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_inpainting_image(left_panel, I->Source);
I->debug_display_left(I->Source);
}
void VisCompUI::cb_source1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_source1_i(o,v);
}

void VisCompUI::cb_mask2_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(left_panel, I->Init_Filled);
I->debug_display_left(I->Init_Filled);
}
void VisCompUI::cb_mask2(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_mask2_i(o,v);
}

void VisCompUI::cb_fill_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(left_panel, I->Fill_Front);
I->debug_display_left(I->Fill_Front);
}
void VisCompUI::cb_fill(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_fill_i(o,v);
}

void VisCompUI::cb_unfilled_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(left_panel, I->Unfilled);
I->debug_display_left(I->Unfilled);
}
void VisCompUI::cb_unfilled(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_unfilled_i(o,v);
}

void VisCompUI::cb_confidence_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(left_panel, I->Confidence);
I->debug_display_left(I->Confidence);
}
void VisCompUI::cb_confidence(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_confidence_i(o,v);
}

void VisCompUI::cb_inpainted1_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_inpainting_image(left_panel, I->Inpainted);
I->debug_display_left(I->Inpainted);
}
void VisCompUI::cb_inpainted1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_inpainted1_i(o,v);
}

Fl_Menu_Item VisCompUI::menu_Left1[] = {
 {"  ", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"source", 0,  (Fl_Callback*)VisCompUI::cb_source1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"mask", 0,  (Fl_Callback*)VisCompUI::cb_mask2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"fill front", 0,  (Fl_Callback*)VisCompUI::cb_fill, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"unfilled", 0,  (Fl_Callback*)VisCompUI::cb_unfilled, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"confidence", 0,  (Fl_Callback*)VisCompUI::cb_confidence, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"inpainted", 0,  (Fl_Callback*)VisCompUI::cb_inpainted1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void VisCompUI::cb_source2_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_inpainting_image(right_panel, I->Source);
I->debug_display_right(I->Source);
}
void VisCompUI::cb_source2(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_source2_i(o,v);
}

void VisCompUI::cb_mask3_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(right_panel, I->Init_Filled);
I->debug_display_right(I->Init_Filled);
}
void VisCompUI::cb_mask3(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_mask3_i(o,v);
}

void VisCompUI::cb_fill1_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(right_panel, I->Fill_Front);
I->debug_display_right(I->Fill_Front);
}
void VisCompUI::cb_fill1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_fill1_i(o,v);
}

void VisCompUI::cb_unfilled1_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(right_panel, I->Unfilled);
I->debug_display_right(I->Unfilled);
}
void VisCompUI::cb_unfilled1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_unfilled1_i(o,v);
}

void VisCompUI::cb_confidence1_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
// this function is used for displaying 1-band images 
display_inpainting_image1(right_panel, I->Confidence);
I->debug_display_right(I->Confidence);
}
void VisCompUI::cb_confidence1(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_confidence1_i(o,v);
}

void VisCompUI::cb_inpainted2_i(Fl_Menu_*, void*) {
  // display the image in a panel of the UI
// the function below is defined in fluid
display_inpainting_image(right_panel, I->Inpainted);
I->debug_display_right(I->Inpainted);
}
void VisCompUI::cb_inpainted2(Fl_Menu_* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_inpainted2_i(o,v);
}

Fl_Menu_Item VisCompUI::menu_Right1[] = {
 {"  ", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"source", 0,  (Fl_Callback*)VisCompUI::cb_source2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"mask", 0,  (Fl_Callback*)VisCompUI::cb_mask3, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"fill front", 0,  (Fl_Callback*)VisCompUI::cb_fill1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"unfilled", 0,  (Fl_Callback*)VisCompUI::cb_unfilled1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"confidence", 0,  (Fl_Callback*)VisCompUI::cb_confidence1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"inpainted", 0,  (Fl_Callback*)VisCompUI::cb_inpainted2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void VisCompUI::cb_Iterations_i(Fl_Input* o, void*) {
  {
  int i;

  sscanf(((Fl_Input *)o)->value(),"%d", &i);
  if (i > 0)
      inpainting_iterations_per_step = i;
};
}
void VisCompUI::cb_Iterations(Fl_Input* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Iterations_i(o,v);
}

void VisCompUI::cb_Patch_i(Fl_Counter* o, void*) {
  I->set_patch_radius((int)(((Fl_Counter *)o)->value()));
}
void VisCompUI::cb_Patch(Fl_Counter* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Patch_i(o,v);
}

void VisCompUI::cb_patches_i(Fl_Check_Button* o, void*) {
  I->debug_show_PSI(((Fl_Check_Button *)o)->value());
}
void VisCompUI::cb_patches(Fl_Check_Button* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_patches_i(o,v);
}

void VisCompUI::cb_vectors_i(Fl_Check_Button* o, void*) {
  I->debug_show_vecs(((Fl_Check_Button *)o)->value());
}
void VisCompUI::cb_vectors(Fl_Check_Button* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_vectors_i(o,v);
}

void VisCompUI::cb_intensities_i(Fl_Check_Button* o, void*) {
  I->debug_print(((Fl_Check_Button *)o)->value());
}
void VisCompUI::cb_intensities(Fl_Check_Button* o, void* v) {
  ((VisCompUI*)(o->parent()->parent()->user_data()))->cb_intensities_i(o,v);
}

void VisCompUI::cb_Brush_i(Fl_Counter* o, void*) {
  left_panel->set_brush_radius(((Fl_Counter *)o)->value());
right_panel->set_brush_radius(((Fl_Counter *)o)->value());
}
void VisCompUI::cb_Brush(Fl_Counter* o, void* v) {
  ((VisCompUI*)(o->parent()->user_data()))->cb_Brush_i(o,v);
}

void VisCompUI::show() {
  mainWindow->show();
}

vil_image_view<vil_rgb<vxl_byte> > VisCompUI::interactive_load_image(vcl_string title) {
  vil_image_view<vil_rgb<vxl_byte> > im;
  char* str;
  
  // load image using VXL libary routines
  if ((str = fl_file_chooser(title.c_str(), "", "")) == NULL)
     // if there was a problem with the filename or the load was cancelled, we return 
     // an empty image
     return im;
  im = load_image(str);
  // check if the loaded image contains valid data (it would not
  // if there was a problem with image loading)
  if ((bool)im == false) 
     fl_alert("VisCompUI::interactive_load_image(): Error opening image file.");
  return im;
}

vil_image_view<vxl_byte> VisCompUI::interactive_load_image1(vcl_string title) {
  vil_image_view<vxl_byte> im;
  char* str;
  
  // load image using VXL libary routines
  if ((str = fl_file_chooser(title.c_str(), "", "")) == NULL)
     // if there was a problem with the filename or the load was cancelled, we return 
     // an empty image
     return im;
  im = load_image1(str);
  // check if the loaded image contains valid data (it would not
  // if there was a problem with image loading)
  if ((bool)im == false) 
     fl_alert("VisCompUI::interactive_load_image1(): Error opening image file.");
  return im;
}

void VisCompUI::set_matting(matting m) {
  M = m;
}

void VisCompUI::display_matting_image(ImDraw* panel, matting::im_type imt) {
  // display the specified image stored in the matting data structure on a display panel
  // if the set routine returns false (eg. the image specified by the user does not exist)
  if (panel->set(M.get(imt),M.get_title(imt)) == false)
          // return a message
  	fl_alert("VisCompUI::display_matting_image(): Matting image is not available for display.");
}

void VisCompUI::display_matting_image1(ImDraw* panel, matting::im_type imt) {
  // display the specified image stored in the matting data structure on a display panel
  // if the set routine returns false (eg. the image specified by the user does not exist)
  // this function is identical to dispay_matting_image(), except that it handles
  // 1-band (aka 1-plane, aka grayscale images)
  // the only difference is the use of the get1() accessor instead of get()
  if (panel->set(M.get1(M.Alpha),M.get_title(M.Alpha)) == false)
          // return a message
  	fl_alert("VisCompUI::display_matting_image1(): Matting image is not available for display.");
}

void VisCompUI::load_and_display_matting_image(ImDraw* panel, matting::im_type imt) {
  // load an image interactively and store it in the matting data structure
  // as specified by the "image type" parameter imt
  if (M.set(imt, interactive_load_image(M.get_title(imt))) == true)
  	// if the image was loaded in the data structure correctly, show it in the
  	// specified panel    
  	display_matting_image(panel,imt);
  else
  	fl_alert("VisCompUI::load_and_display_matting_image(): Image load failed.");
}

void VisCompUI::set_inpainting(inpainting* inp) {
  I = inp;
}

void VisCompUI::display_inpainting_image(ImDraw* panel, inpainting::im_type imt) {
  // display the specified image stored in the inpainting data structure on a display panel
  // if the set routine returns false (eg. the image specified by the user does not exist)
  if (panel->set(I->get(imt),I->get_title(imt)) == false)
          // return a message
  	fl_alert("VisCompUI::display_matting_image(): Inpainting image is not available for display.");
}

void VisCompUI::display_inpainting_image1(ImDraw* panel, inpainting::im_type imt) {
  // display the specified image stored in the inpainting data structure on a display panel
  // if the set routine returns false (eg. the image specified by the user does not exist)
  // this function is identical to dispay_inpainting_image(), except that it handles
  // 1-band (aka 1-plane, aka grayscale images)
  // the only difference is the use of the get1() accessor instead of get()
  
     if (panel->set(I->get1(imt),I->get_title(imt)) == false)
          // return a message
  	fl_alert("VisCompUI::display_inpainting_image1(): Inpainting image is not available for display.");
}

void VisCompUI::load_and_display_inpainting_image(ImDraw* panel, inpainting::im_type imt) {
  // load an image interactively and store it in the inpainting data structure
  // as specified by the "image type" parameter imt
  if (I->set(imt, interactive_load_image(I->get_title(imt))) == true)
  	// if the image was loaded in the data structure correctly, show it in the
  	// specified panel    
  	display_inpainting_image(panel,imt);
  else
  	fl_alert("VisCompUI::load_and_display_inpainting_image(): Image load failed.");
}

void VisCompUI::load_and_display_inpainting_image1(ImDraw* panel, inpainting::im_type imt) {
  // load a 1-band image interactively and store it in the inpainting data structure
  // as specified by the "image type" parameter imt
  if (I->set(imt, interactive_load_image1(I->get_title(imt))) == true)
  	// if the image was loaded in the data structure correctly, show it in the
  	// specified panel    
  	display_inpainting_image1(panel,imt);
  else
  	fl_alert("VisCompUI::load_and_display_inpainting_image1(): Image load failed.");
}

VisCompUI::VisCompUI() {
  { mainWindow = new Fl_Double_Window(850, 505, "Visual Computing User Interface");
    mainWindow->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(0, 1, 850, 25);
      o->end();
    } // Fl_Group* o
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 1, 850, 25, "Main Menu Bar");
      o->box(FL_BORDER_BOX);
      { Fl_Menu_Item* o = &menu_Main[11];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method */
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Back1).c_str());
      }
      { Fl_Menu_Item* o = &menu_Main[12];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Back2).c_str());
      }
      { Fl_Menu_Item* o = &menu_Main[13];
        /* this snippet of code allows the menu item to have a variable appearance*/
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels*/
        o->label(M.get_title(M.Comp1).c_str());
      }
      { Fl_Menu_Item* o = &menu_Main[14];
        /* this snippet of code allows the menu item to have a variable appearance*/
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels*/
        o->label(M.get_title(M.Comp2).c_str());
      }
      { Fl_Menu_Item* o = &menu_Main[22];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method */
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Source).c_str());
      }
      { Fl_Menu_Item* o = &menu_Main[23];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Init_Filled).c_str());
      }
      { Fl_Menu_Item* o = &menu_Main[26];
        o->label(I->get_title(I->Inpainted).c_str());
      }
      { Fl_Menu_Item* o = &menu_Main[27];
        o->label(I->get_title(I->Init_Filled).c_str());
      }
      o->menu(menu_Main);
    } // Fl_Menu_Bar* o
    { Fl_Choice* o = new Fl_Choice(5, 35, 105, 25, "Mode Selection");
      o->tooltip("Choose the operating mode of the user interface");
      o->down_box(FL_BORDER_BOX);
      o->labeltype(FL_NO_LABEL);
      o->menu(menu_Mode);
    } // Fl_Choice* o
    { Fl_Group* o = new Fl_Group(115, 35, 360, 455);
      { left_panel = new ImDraw(115, 60, 360, 360);
        left_panel->tooltip("Browse mode: left-click recenters image\r\nDraw mode: left-drag draws rectang\
le");
        left_panel->box(FL_NO_BOX);
        left_panel->color(FL_BACKGROUND_COLOR);
        left_panel->selection_color(FL_BACKGROUND_COLOR);
        left_panel->labeltype(FL_NORMAL_LABEL);
        left_panel->labelfont(0);
        left_panel->labelsize(14);
        left_panel->labelcolor(FL_FOREGROUND_COLOR);
        left_panel->align(Fl_Align(FL_ALIGN_CENTER));
        left_panel->when(FL_WHEN_CHANGED);
      } // ImDraw* left_panel
      { left_pos = new Fl_Output(285, 430, 100, 20, "Cursor:");
        left_pos->tooltip("(i,j) pixel coordinates at mouse position");
        left_pos->box(FL_FLAT_BOX);
        left_pos->color(FL_BACKGROUND_COLOR);
        left_pos->labelsize(10);
        left_pos->textsize(10);
      } // Fl_Output* left_pos
      { left_val = new Fl_Output(285, 450, 100, 20, "Value:");
        left_val->tooltip("(R,G,B) values of pixel at mouse position");
        left_val->box(FL_FLAT_BOX);
        left_val->color(FL_BACKGROUND_COLOR);
        left_val->labelsize(10);
        left_val->textsize(10);
      } // Fl_Output* left_val
      { left_mag = new Fl_Input(175, 430, 60, 20, "Zoom:");
        left_mag->tooltip("zoom<ENTER>\r\nsets the magnification of current image");
        left_mag->labelsize(10);
        left_mag->textsize(10);
        left_mag->callback((Fl_Callback*)cb_left_mag);
        left_mag->when(FL_WHEN_ENTER_KEY);
      } // Fl_Input* left_mag
      { left_center_i = new Fl_Input(175, 450, 60, 20, "Center I:");
        left_center_i->tooltip("Center image on pixel (i,j)");
        left_center_i->labelsize(10);
        left_center_i->textsize(10);
        left_center_i->callback((Fl_Callback*)cb_left_center_i);
        left_center_i->when(FL_WHEN_ENTER_KEY);
      } // Fl_Input* left_center_i
      { left_center_j = new Fl_Input(175, 470, 60, 20, "Center J:");
        left_center_j->tooltip("Center image on pixel (i,j)");
        left_center_j->labelsize(10);
        left_center_j->textsize(10);
        left_center_j->callback((Fl_Callback*)cb_left_center_j);
        left_center_j->when(FL_WHEN_ENTER_KEY);
      } // Fl_Input* left_center_j
      { left_title = new Fl_Output(115, 35, 360, 20, "Title");
        left_title->box(FL_FLAT_BOX);
        left_title->color(FL_BACKGROUND_COLOR);
        left_title->labeltype(FL_NO_LABEL);
        left_title->labelfont(1);
      } // Fl_Output* left_title
      { Fl_Button* o = new Fl_Button(250, 470, 105, 20, "Canonical view");
        o->color(FL_BACKGROUND2_COLOR);
        o->labelsize(10);
        o->callback((Fl_Callback*)cb_Canonical);
        o->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(480, 35, 360, 455);
      { right_panel = new ImDraw(480, 60, 360, 360);
        right_panel->tooltip("Browse mode: left-click recenters image\r\nDraw mode: left-drag draws rectang\
le");
        right_panel->box(FL_NO_BOX);
        right_panel->color(FL_BACKGROUND_COLOR);
        right_panel->selection_color(FL_BACKGROUND_COLOR);
        right_panel->labeltype(FL_NORMAL_LABEL);
        right_panel->labelfont(0);
        right_panel->labelsize(14);
        right_panel->labelcolor(FL_FOREGROUND_COLOR);
        right_panel->align(Fl_Align(FL_ALIGN_CENTER));
        right_panel->when(FL_WHEN_CHANGED);
      } // ImDraw* right_panel
      { right_pos = new Fl_Output(650, 430, 100, 20, "Cursor:");
        right_pos->tooltip("(i,j) pixel coordinates at mouse position");
        right_pos->box(FL_FLAT_BOX);
        right_pos->color(FL_BACKGROUND_COLOR);
        right_pos->labelsize(10);
        right_pos->textsize(10);
      } // Fl_Output* right_pos
      { right_val = new Fl_Output(650, 450, 100, 20, "Value:");
        right_val->tooltip("(R,G,B) values of pixel at mouse position");
        right_val->box(FL_FLAT_BOX);
        right_val->color(FL_BACKGROUND_COLOR);
        right_val->labelsize(10);
        right_val->textsize(10);
      } // Fl_Output* right_val
      { right_mag = new Fl_Input(540, 430, 60, 20, "Zoom:");
        right_mag->tooltip("zoom<ENTER>\r\nsets the magnification of current image");
        right_mag->labelsize(10);
        right_mag->textsize(10);
        right_mag->callback((Fl_Callback*)cb_right_mag);
        right_mag->when(FL_WHEN_ENTER_KEY);
      } // Fl_Input* right_mag
      { right_center_i = new Fl_Input(540, 450, 60, 20, "Center I:");
        right_center_i->tooltip("Center image on pixel (i,j)");
        right_center_i->labelsize(10);
        right_center_i->textsize(10);
        right_center_i->callback((Fl_Callback*)cb_right_center_i);
        right_center_i->when(FL_WHEN_ENTER_KEY);
      } // Fl_Input* right_center_i
      { right_center_j = new Fl_Input(540, 470, 60, 20, "Center J:");
        right_center_j->tooltip("Center image on pixel (i,j)");
        right_center_j->labelsize(10);
        right_center_j->textsize(10);
        right_center_j->callback((Fl_Callback*)cb_right_center_j);
        right_center_j->when(FL_WHEN_ENTER_KEY);
      } // Fl_Input* right_center_j
      { right_title = new Fl_Output(480, 35, 360, 20, "Title");
        right_title->box(FL_FLAT_BOX);
        right_title->color(FL_BACKGROUND_COLOR);
        right_title->labeltype(FL_NO_LABEL);
        right_title->labelfont(1);
      } // Fl_Output* right_title
      { Fl_Button* o = new Fl_Button(615, 470, 105, 20, "Canonical view");
        o->color(FL_BACKGROUND2_COLOR);
        o->labelsize(10);
        o->callback((Fl_Callback*)cb_Canonical1);
        o->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    mainWindow->end();
  } // Fl_Double_Window* mainWindow
  { mattingDisplayWindow = new Fl_Double_Window(373, 55, "Matting Display Control");
    mattingDisplayWindow->user_data((void*)(this));
    { Fl_Choice* o = new Fl_Choice(5, 20, 150, 25, "Left Image");
      o->tooltip("Choose the operating mode of the user interface");
      o->down_box(FL_BORDER_BOX);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Menu_Item* o = &menu_Left[1];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Back1).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left[2];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Back2).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left[3];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Comp1).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left[4];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Comp2).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left[5];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Alpha).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left[6];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.Object).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left[7];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.NewBack).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left[8];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file matting.cxx for definitions of these labels */
        o->label(M.get_title(M.NewComp).c_str());
      }
      o->menu(menu_Left);
    } // Fl_Choice* o
    { Fl_Choice* o = new Fl_Choice(165, 20, 150, 25, "Right  Image");
      o->tooltip("Choose the operating mode of the user interface");
      o->down_box(FL_BORDER_BOX);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      o->menu(menu_Right);
    } // Fl_Choice* o
    mattingDisplayWindow->end();
  } // Fl_Double_Window* mattingDisplayWindow
  inpainting_iterations_per_step = 1;
  { inpaintingDisplayWindow = new Fl_Double_Window(320, 146, "Inpainting Control");
    inpaintingDisplayWindow->user_data((void*)(this));
    { Fl_Choice* o = new Fl_Choice(5, 20, 150, 25, "Left Image");
      o->tooltip("Choose the image to display in the left panel");
      o->down_box(FL_BORDER_BOX);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Menu_Item* o = &menu_Left1[1];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Source).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left1[2];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Init_Filled).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left1[3];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Fill_Front).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left1[4];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Unfilled).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left1[5];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Confidence).c_str());
      }
      { Fl_Menu_Item* o = &menu_Left1[6];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Inpainted).c_str());
      }
      o->menu(menu_Left1);
    } // Fl_Choice* o
    { Fl_Choice* o = new Fl_Choice(165, 20, 150, 25, "Right  Image");
      o->tooltip("Choose the image to display in the right panel");
      o->down_box(FL_BORDER_BOX);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Menu_Item* o = &menu_Right1[1];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Source).c_str());
      }
      { Fl_Menu_Item* o = &menu_Right1[2];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Init_Filled).c_str());
      }
      { Fl_Menu_Item* o = &menu_Right1[3];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Fill_Front).c_str());
      }
      { Fl_Menu_Item* o = &menu_Right1[4];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Unfilled).c_str());
      }
      { Fl_Menu_Item* o = &menu_Right1[5];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Confidence).c_str());
      }
      { Fl_Menu_Item* o = &menu_Right1[6];
        /* this snippet of code allows the menu item to have a variable appearance */
        /* in the actual UI, the menu item's label will be the string returned by the get_title() method*/
        /* see the file inpainting.cxx for definitions of these labels */
        o->label(I->get_title(I->Inpainted).c_str());
      }
      o->menu(menu_Right1);
    } // Fl_Choice* o
    { Fl_Input* o = new Fl_Input(5, 65, 150, 25, "Iterations Per Run");
      o->tooltip("How many iterations should be run each time \"Run Algorithm\" is selected fro\
m the menu");
      o->callback((Fl_Callback*)cb_Iterations);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      o->when(FL_WHEN_ENTER_KEY);
    } // Fl_Input* o
    { Fl_Counter* o = new Fl_Counter(165, 65, 150, 25, "Patch Radius");
      o->tooltip("The radius of the patch (patch width & height will be 2*radius+1)");
      o->minimum(1);
      o->maximum(20);
      o->step(1);
      o->value(4);
      o->callback((Fl_Callback*)cb_Patch);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
    } // Fl_Counter* o
    { Fl_Group* o = new Fl_Group(5, 110, 150, 25, "Show Debug Info");
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Check_Button* o = new Fl_Check_Button(15, 110, 15, 25, "patches");
        o->tooltip("Show highest-priority patch on fill front (yellow) and most similar patch in \
source image (red) in the current iteration");
        o->down_box(FL_DOWN_BOX);
        o->labelsize(9);
        o->callback((Fl_Callback*)cb_patches);
        o->align(Fl_Align(FL_ALIGN_BOTTOM_LEFT));
      } // Fl_Check_Button* o
      { Fl_Check_Button* o = new Fl_Check_Button(60, 110, 15, 25, "vectors");
        o->tooltip("Show direction of largest gradient (red) and fill front normal (green) at the\
 highest-priority patch in current iteration");
        o->down_box(FL_DOWN_BOX);
        o->labelsize(9);
        o->callback((Fl_Callback*)cb_vectors);
        o->align(Fl_Align(FL_ALIGN_BOTTOM_LEFT));
      } // Fl_Check_Button* o
      { Fl_Check_Button* o = new Fl_Check_Button(105, 110, 15, 25, "intensities");
        o->tooltip("Enable printing of patch intensities");
        o->down_box(FL_DOWN_BOX);
        o->labelsize(9);
        o->callback((Fl_Callback*)cb_intensities);
        o->align(Fl_Align(FL_ALIGN_BOTTOM_LEFT));
      } // Fl_Check_Button* o
      o->end();
    } // Fl_Group* o
    { Fl_Counter* o = new Fl_Counter(165, 110, 150, 25, "Brush Radius");
      o->tooltip("The radius of the mask brush");
      o->minimum(1);
      o->maximum(100);
      o->step(1);
      o->value(10);
      o->callback((Fl_Callback*)cb_Brush);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
    } // Fl_Counter* o
    inpaintingDisplayWindow->end();
  } // Fl_Double_Window* inpaintingDisplayWindow
}
